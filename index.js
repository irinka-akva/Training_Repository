
// 1. even-or-odd
// Создайте функцию, которая принимает целое число в качестве аргумента и возвращает 
// "Четное" для четных чисел или "Нечетное" для нечетных чисел.

function evenOrOdd(number) {
    if (number % 2 === 0) {
        return "even";
    } return "odd";
}

// console.log(evenOrOdd(17));

// 2. opposite-number
// Задав целое число или число с плавающей запятой, найдите его противоположность.

function opposite(number) {
    return -number;
}

// console.log(opposite(5));

//  3. century-from-year
// Первое столетие охватывает период с 1-го по 100-й год включительно, второе столетие - со 101-го
//  по 200-й год включительно и т.д.
// Задача
// Учитывая год, верните век, в котором он находится.

function century(year) {
    return Math.ceil(year / 100);
}

// console.log(century(2000));

// 4. abbreviate-a-two-word-name
// Напишите функцию для преобразования имени в инициалы. Это ката состоит строго из двух слов с одним пробелом между ними.
// Выходные данные должны состоять из двух заглавных букв с разделяющей их точкой.

function abbrevName(name) {
    let arr = name.split(" ").map(elem => elem.slice(0, 1).toUpperCase()).join(".");
    return arr;
}

// console.log(abbrevName("иванов виктор"));


// 5. reversed-strings
// Завершите решение так, чтобы оно изменило переданную в него строку на противоположную.

function solution(str) {
    return str.split("").reverse().join("");
}

// console.log(solution("ветер"));

// 6. credit-card-mask
// Обычно, когда вы что-то покупаете, вас спрашивают, верны ли по-прежнему номер вашей кредитной карты,
//  номер телефона или ответ на ваш самый секретный вопрос. Однако, поскольку кто-то может заглянуть вам через плечо,
//   вы не хотите, чтобы это отображалось на вашем экране. Вместо этого мы маскируем это.
// Ваша задача состоит в том, чтобы написать функцию maxify, которая изменяет все символы, кроме последних четырех, на '#'.

function maskify(cc) {
    let arr = cc.split("");
    for (let i = 0; i < arr.length - 4; i++) {
        arr[i] = "#";
    }
    return arr.join("");
}

// console.log(maskify("1dgw5"));

// 7. remove-first-and-last-character
// Ваша цель - создать функцию, которая удаляет первый и последний символы строки.
//  Вам задан один параметр - исходная строка. Вам не нужно беспокоиться о строках, содержащих менее двух символов.

function removeChar(str) {

    return str.substring(1, str.length - 1);

    //     let arr = str.split("");
    //     arr.shift();
    //     arr.pop();

    //   return arr.join("");
};

//    console.log(removeChar("Палитра"));


//    8. create-phone-number
// Напишите функцию, которая принимает массив из 10 целых чисел (от 0 до 9) и возвращает
//     строку из этих чисел в виде номера телефона.

function createPhoneNumber(numbers) {
    return "(" + numbers.slice(0, 3).join("") + ") " + numbers.slice(3, 6).join("") + "-" + numbers.slice(6).join("");
}

// console.log(createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]));

// 9. How many arguments
// Создайте функцию с именем args_count, которая возвращает количество предоставленных аргументов

function args_count() {
    return arguments.length;
}

// console.log(args_count(1, 5, 8));

// 10. Leap Years
// В этом ката вы должны просто определить, является ли данный год високосным или нет.
//  На случай, если вы не знаете правил, вот они:
// годы, кратные 4, являются високосными годами, но годы, кратные 100, не являются високосными годами,
//  а годы, кратные 400, являются високосными годами.

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// console.log(isLeapYear(2015));

// 11. If you can't sleep, just count
//  sheepУчитывая неотрицательное целое число, например 3, верните строку с бормотанием:
//  "1 овца... 2 овцы ... 3 овцы ...". Ввод всегда будет действительным, т.е. никаких отрицательных целых чисел.

var countSheep = function (num) {
    let str = "";
    for (let i = 1; i <= num; i++) {
        str += (i + " sheep...");
    }
    return str;
}

//   console.log(countSheep(5));


//   12.  String insert values.
//  Задана строка и объект/массив, вам нужно вернуть отформатированную строку. Замените все вхождения в строке,
//    где имя ключа в объекте заключено в фигурные скобки.

var format = function (str, obj) {
    let arr = str.split(" ");
    for (let i = 0; i < arr.length; i++) {
        if (arr[i].match(/(?<=\{).+(?=\})/)) {
            let key = arr[i].slice(arr[i].indexOf("{") + 1, arr[i].indexOf("}"));
            if (obj[key] || obj[key] == 0) {
                arr[i] = obj[key] + (arr[i].match(/(?<=\}).+/) || "");
            }
        }
    }
    return arr.join(" ");
};

// var s = 'Hello {0} - {foobar} make me {2} {1} - I\'m full..';
// var a = ['Jack', 'sandwiches', 0];
// console.log(format(s, a)); 

// 13. sum-of-positive 
// Вы получаете массив чисел, возвращаете сумму всех положительных значений.
// Пример [1,-4,7,12] => 1 + 7 + 12 = 20
// Примечание: если суммировать нечего, то по умолчанию сумма равна 0.

function positiveSum(arr) {
    let sum = 0;
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] > 0) {
            sum += arr[i];
        }
    }
    return sum;
}

// console.log(positiveSum([-1, -5, 10, -4, -4])); 

// 14. shortest-word
// учитывая строку слов, возвращает длину самого короткого слова (ов).
// Строка никогда не будет пустой, и вам не нужно учитывать различные типы данных.

function findShort(s) {
    let arr = s.split(" ");
    let minLength = arr[0].length;
    console.log(arr);

    for (let i = 0; i < arr.length; i++) {
        if (minLength > arr[i].length) {
            minLength = arr[i].length;
        }
    }

    return minLength;
}

// console.log(findShort("Mine Factom Waves Factom")); 

// 15. list-filtering 
// В этом ката вы создадите функцию, которая принимает список неотрицательных целых чисел
//  и строк и возвращает новый список с отфильтрованными строками.

function filter_list(l) {
    let newArr = [];
    for (let i = 0; i < l.length; i++) {
        if (typeof l[i] === "number") {
            newArr.push(l[i]);
        }
    }
    return newArr;
}

//   console.log(filter_list([1,2,'a','b', 524])); 

// 16. Build a square
// Я дам вам целое число. Верните мне фигуру такой же длины и ширины, как целое число.
//  Целым числом будет целое число от 1 до 50.
//  n = 3, поэтому я ожидаю вернуть квадрат размером 3х3, в виде строки.

function generateShape(integer) {
    return ("+".repeat(integer) + "\n").repeat(integer).trim();
}

// console.log(generateShape(4)); 

let str1 = "привет{это}!?";
// console.log(str1.match(/\{\W\W\W\}/g));

// 17. Vowel Count
// Возвращает количество (count) гласных в данной строке.
// Мы будем рассматривать a, e, i, o, u в качестве гласных для этого Kat (но не y).
// Входная строка будет состоять только из строчных букв и/или пробелов.


function getCount(str) {
    const arrOfVowels = ["a", "e", "i", "o", "u"];
    let arr = str.split("");
    let count = 0;
    for (let i = 0; i < arr.length; i++) {
        if (arrOfVowels.indexOf(arr[i]) !== -1) {
            count += 1;
        };
    }
    return count;
}

// console.log(getCount("abraue"));

// 18. playing-with-digits 
// Некоторые числа обладают забавными свойствами. Например:
// 89 --> 8¹ + 9² = 89 * 1
// 695 --> 6² + 9³ + 5⁴= 1390 = 695 * 2
// 46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51
// Дано положительное целое число n, записанное как abcd... (a, b, c, d... - цифры) и положительное целое число p
// мы хотим найти положительное целое число k, если оно существует, такое, чтобы сумма цифр числа n, взятых в последовательных
//  степенях p, была равна k * n.
// Другими словами:
// Существует ли целое число k, такое как : (a ^ p + b ^ (p+ 1) + c ^ (p + 2) + d ^ (p + 3) + ...) = n * k
// Если это так, мы вернем k, если нет, вернем -1.
// Примечание: n и p всегда будут задаваться как строго положительные целые числа.

function digPow(n, p) {
    arrN = n.toString().split('');
    let result = 0;
    for (let i = 0; i < arrN.length; i++) {
        result += arrN[i] ** p;
        p++;
        console.log(result);
    }
    return result % n ? -1 : (result / n);
}

// console.log(digPow(46288, 3)); //51

//   19. Smallest value of an array
// Напишите функцию, которая может возвращать наименьшее значение массива или индекс
//  этого значения. 2-й параметр функции укажет, должна ли она возвращать значение или индекс.
//   Предположим, что первым параметром всегда будет массив, заполненный как минимум 1 числом
//    и не содержащий дубликатов. Предположим, что вторым параметром будет строка, содержащая одно
//     из двух значений: 'value' и 'index'.

function min(arr, toReturn) {
    let minNum = Math.min(...arr);
    if (toReturn === 'value') {
        return minNum;
    } else {
        return arr.indexOf(minNum);
    }
}

//   console.log(min([12,2,3,4,5], 'index'));

// 20. array-dot-diff
// Ваша цель - реализовать функцию разности, которая вычитает один список из другого и возвращает результат.
// Он должен удалить все значения из списка a, которые присутствуют в списке b, сохраняя их порядок.
// Если значение присутствует в b, все его вхождения должны быть удалены из другого.

function arrayDiff(a, b) {
    let newArr = [];
    for (let i = 0; i < a.length; i++) {
        if (b.indexOf(a[i]) === -1) {
            newArr.push(a[i]);
        }
    }
    return newArr;
}

// console.log(arrayDiff([1, 2, 2, 5, 10], [1, 2])); 

// 21. find-the-capitals-1 
// Напишите функцию, которая принимает в качестве аргумента одну строку (слово).
// Функция должна возвращать упорядоченный список, содержащий индексы всех заглавных букв в строке.

var capitals = function (word) {
    let newArr = [];
    for (let i = 0; i < word.length; i++) {
        if (/^\p{Lu}/u.test(word[i])) {
            newArr.push(i);
        }
    }
    return newArr;
};

// console.log(capitals('CodEWaRs'));

// 22. insert-dashes
//  Напишите функцию insert_dash(num) / insert Dash(num) / Insert Dash(int num), которая будет вставлять 
// тире ('-') между каждыми двумя нечетными цифрами в num. Например: если число равно 454793, то вывод должен
//  быть 4547-9-3. Не считайте ноль нечетной цифрой.
// Обратите внимание, что число всегда будет неотрицательным (>= 0).

function insertDash(num) {
    let arr = num.toString().split("");
    let str = "";
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] % 2 !== 0 && arr[i + 1] % 2 !== 0) {
            str += arr[i] + "-";
        } else {
            str += arr[i];
        }
    }
    return str;
}

// console.log(insertDash(123569));

// 23. homogenous-arrays
// Учитывая двумерный массив, верните новый массив, который переносит только те массивы из исходного,
//  которые не были пустыми и все элементы которых имеют один и тот же тип (т.е. однородны). Для простоты
//   массивы внутри массива будут содержать только символы и целые числа.
// Пример:
// Данный [[1, 5, 4], [' a', 3, 5], ['b'], [], ['1', 2, 3]], ваша функция должна возвращать [[1, 5, 4], [' b']].
// Дополнение:
// Пожалуйста, имейте в виду, что для этого ката мы предполагаем, что пустые массивы не являются однородными.
// Результирующие массивы должны располагаться в том порядке, в котором они были изначально, и их значения не должны изменяться.
// Неявное приведение типов не допускается. Подмассив [1, '2'] будет считаться незаконным и должен быть отфильтрован.

function filterHomogenous(arrays) {
    return arrays.filter(b => b.length > 0 && b.every(e => typeof e == typeof b[0]));
}

// console.log(filterHomogenous([[1, 5, 4], ['a', 3, 5], ['b'], [], ['', '1'], ['1', 2, 3]]));

// 24. lottery-ticket
// Получив лотерейный билет (ticket), представленный массивом из 2-значных массивов, вы должны выяснить, выиграли ли вы джекпот.
// Пример заявки: [ [ 'ABC', 65 ], [ 'HGR', 74 ], [ 'BYHT', 74 ] ]
// Чтобы сделать это, вы должны сначала подсчитать "мини-выигрыши" в вашем билете. Каждый подмассив содержит в себе как строку,
//  так и число. Если код любого из символов в строке совпадает с номером, вы получаете мини-выигрыш. Обратите внимание, что
//  у вас может быть только один мини-выигрыш на каждый дополнительный набор.
// Как только вы подсчитаете все свои мини-выигрыши, сравните это число с другими предоставленными данными (выигрыш). 
// Если ваша сумма больше или равна (выигрыш), верните 'Winner!'. Иначе верните 'Loser!'.
// Все вводимые данные будут в правильном формате. Строки в билетах не всегда одинаковой длины.

function bingo(ticket, win) {
    let miniWin = 0;
    for (let i = 0; i < ticket.length; i++) {
        for (let j = 0; j < ticket[i][0].length; j++) {
            if (ticket[i][0].charCodeAt(j) === ticket[i][1]) {
                miniWin++;
                break;
            }
        }
    };
    return miniWin >= win ? 'Winner!' : 'Loser!';
}

// console.log(bingo([["ZPAPYOEF",90], ["PJRIJ",81], ["BHWSVM",70], ["EJQEINSG",66], ["PPHX",86], ["BXMBEQ",66], ["RN",69]], 3)); 

// 25. row-weights. 
// Несколько человек стоят в ряд, разделенные на две команды.
// Первый человек переходит в команду 1, второй переходит в команду 2, третий переходит в команду 1 и так далее.
// Задача
// Учитывая массив целых положительных чисел (веса людей), верните новый массив/кортеж из двух целых чисел, где первое
//  - это общий вес команды 1, а второе - общий вес команды 2.
// Записи
// Размер массива равен не менее 1.
// Все числа будут положительными.

function rowWeights(array) {
    let weight1 = 0;
    let weight2 = 0;
    for (let i = 0; i < array.length; i++) {
        i % 2 === 0 ? weight1 += array[i] : weight2 += array[i];
    }
    return [weight1, weight2];
}

//   console.log(rowWeights([50,60,70,80])); //[120,140]

//   26. scrolling-text. 
// Давайте создадим немного прокручивающегося текста!
//   Ваша задача состоит в том, чтобы завершить функцию, которая принимает строку
//   и возвращает массив со всеми возможными поворотами данной строки в верхнем регистре.

function scrollingText(text) {
    let arrFinally = [];
    let arr = text.toUpperCase().split("");
    console.log(arr);
    for (let i = 0; i < arr.length; i++) {
        arrFinally.push(arr.join(""));
        arr.push(arr[0]);
        arr.shift(arr[0]);
    }
    return arrFinally;
}

//   console.log(scrollingText("abc"));

// 27. Write Number in Expanded Form. 
// Вам будет присвоен номер, и вам нужно будет вернуть его в виде строки в развернутом виде. Например:
// развернутая форма(12); // Должна возвращать '10 + 2'
// развернутая форма(42); // Должна возвращать '40 + 2'
// развернутая форма(70304); // Должна возвращать '70000 + 300 + 4 '
// ПРИМЕЧАНИЕ: Все числа будут целыми числами, большими 0.

function expandedForm(num) {
    let arr = num.toString().split("");
    let arrFinally = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] != 0) {
            arrFinally.push(arr[i] * 10 ** (arr.length - (i + 1)));
        }
    }
    return arrFinally.join(" + ");
}

// console.log(expandedForm(70304)); 

// 28. is-every-value-in-the-array-an-array.
// Является ли каждое значение в массиве массивом?
// Это должно проверить только второе измерение массива. Значения вложенных массивов не обязательно должны быть массивами.

const arrCheck = value => {
    return value.every(elem => Array.isArray(elem));
}

// console.log(arrCheck([[1], [2]])); 

// 29. make-a-square-box. 
// Задав число в качестве параметра (от 2 до 30), верните массив, содержащий строки, которые образуют поле.

function box(integer) {
    let arr = [];
    for (let i = 1; i <= integer; i++) {
        i === 1 || i === integer ? arr.push("-".repeat(integer)) : arr.push("-" + " ".repeat(integer - 2) + "-");
    }
    return arr;
}

// console.log(box(5)); //["-----", "-   -", "-   -", "-   -", "-----"]

// 30. magic-index.
// Магический индекс в массиве A[1...n-1] определяется как индекс такой, что A[i] = i. 
// Учитывая отсортированный массив различных целых чисел, напишите метод для поиска магического индекса, если он существует,
//  в массиве A.
// найди волшебство([-20,-10,2,10,20]); // Возвращает 2

function findMagic(arr) {
    return arr.some((elem, index)=> elem == index) ? +(arr.filter((elem, index) => elem == index).join("")) : -1;
}

// console.log(findMagic([-20, -10, 8, 10, 20])); // 2

// 31. Email Address Obfuscator.
// Многие люди предпочитают скрывать свой адрес электронной почты при отображении его в Интернете.
//  Одним из распространенных способов сделать это является замена @ и . символы для их буквенных эквивалентов в квадратных скобках.
// Пример 1:
// user_name@example.com
// => имя_пользователя [at] пример [dot] com
// Используя приведенные выше примеры в качестве руководства, напишите функцию, которая принимает
// строку адреса электронной почты и возвращает запутанную версию в виде строки, заменяющей 
// символы @ и . с [at] и [dot] соответственно.

obfuscate = function(email) {
    return email.replace(/@/g, " [at] ").replace(/\./g, " [dot] ");

  }

//   console.log(obfuscate('te@st@123.rt.com'));

//   32. Excel sheet column numbers.Array
//   Напишите функцию
//   titleToNumber(title) 
// который задает заголовок столбца в том виде, в каком он отображается на листе Excel, возвращает соответствующий ему номер столбца.
//  Заголовки всех столбцов будут написаны в верхнем регистре.
// Примеры:
// название к номеру('A') === 1
// Номер заголовка('Z') === 26
// номер заголовка('AA') === 27
// Примечание для Clojure:
// Не используйте Java Math/pow (даже с bigint), потому
// что при увеличении длины "title" происходит потеря точности.
// Напишите свою собственную функцию "exp [x n]".

  function titleToNumber(title) {
  return title.split("").map(x=> x.charCodeAt(0)-64).reduce((x,y)=> x*26+y)
  }

//   console.log(titleToNumber('BA')); //53

//   33. Count the smiley faces.
//   Учитывая массив (arr) в качестве аргумента, завершите функцию подсчета смайликов,
//    которая должна вернуть общее количество улыбающихся лиц.
// Правила для улыбающегося лица:
// На каждом смайлике должна быть соответствующая пара глаз. Глаза могут быть помечены как: или ;
// У смайлика может быть нос, но это не обязательно. Допустимыми символами для обозначения носа являются - или ~
// У каждого улыбающегося лица должен быть улыбающийся рот, который должен быть отмечен либо ), либо D
// Никакие дополнительные символы не допускаются, за исключением указанных выше.
// Допустимые примеры смайликов: :) :D ;-D :~)
// Недопустимые смайлики: ;( :> :} :]
// Пример
// считайте смайлики([':)', ';(', ';}', ':- D']); // должно вернуться 2;
// подсчитать смайлики([';D', ':-(', ':-)', ';~)']); // должен возвращать 3;
// считайте смайлики([';]', ':[', ';*', ':$', ';- D']); // должен возвращать 1;
// Примечание
// В случае пустого массива верните 0. Вы не будете протестированы с недопустимыми входными данными 
// (входными данными всегда будет массив). Порядок расположения элементов лица (глаза, нос, рот) всегда будет одинаковым.

function countSmileys(arr) {
    let num = 0;
    for (let i = 0; i < arr.length; i++) {
       if ((arr[i][0] === ":" || arr[i][0] === ";") 
       && (arr[i][1] === "-" || arr[i][1] === "~" || arr[i][1] === ")" || arr[i][1] === "D") 
       && (arr[i][2] === ")" || arr[i][2] === "D" || arr[i][2] === undefined)) {
        num++;
       }  
    }
    return num;
  }

//   console.log(countSmileys([":D" , ":~)" , ";~D" , ":)"])); //4


